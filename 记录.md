# springCloud

# 一.SpringCloud是什么?

SpringCloud是一种微服务架构,是一种架构模式。它提倡将单一应用程序划分成一组小的服务,服务之间互相协调,互相配合,为用户提供最终的价值。每个服务运行在独立的进程中,服务于服务间采用轻量级的通信机制互相协作(通常是基于HTTP协议的RESTfulAPI)。每个服务都围绕着具体业务进行构建,并且能够被独立的部署到生产环境,类生产环境等。另外,应当尽量避免统一的集中式的服务管理机制,对具体的一个服务而言.应根据业务上下文,选择合适的语言,工具进行构建

SpringCloud=分布式微服务架构的一站式解决方案,是多种微服务架构落地技术的集合体,俗称微服务全家桶

## 版本控制

cloud中文文档介绍

https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md

2022-5-21截屏:

boot的版本:https://github.com/spring-projects/spring-boot/wiki/

![1653122710435](%E5%9F%BA%E7%A1%80.assets/1653122710435.png)

cloud的版本:https://github.com/spring-cloud/spring-cloud-release/wiki

![1653122693498](%E5%9F%BA%E7%A1%80.assets/1653122693498.png)

查看关联:访问https://start.spring.io/actuator/info,获得json数据再转换一下

![1653122719820](%E5%9F%BA%E7%A1%80.assets/1653122719820.png)

![1653123045189](%E5%9F%BA%E7%A1%80.assets/1653123045189.png)



https://spring.io/projects/spring-cloud#overview也可以通过这个网址看



![1653123034143](%E5%9F%BA%E7%A1%80.assets/1653123034143.png)

版本确定:

cloud:	H sr1

boot: 	2.3.0.RELEASE

cloud alibaba	2.1.0.RELEASE

java:	1.8

Maven:	3.6.3

MySQL:	8.0.19

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.0.RELEASE</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-dependencies</artifactId>
    <version>Hoxton.SR1</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
    <version>2.1.0.RELEASE</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
```

学习技术:

​	服务注册中心

​		1.EurKa(cloud自带)

​		2.Zookeeper

​		3.Consul

​		4.Nacos(重要)

​	服务调用

​		Ribbon

​		loadbalancer	

​	服务调用2

​		Feign(几乎不用了)

​		openFeign

​	服务降级

​		Hystrix(国内)

​		Resilience4java(国外)

​		sentienl(阿里)

​	服务网关

​		zuul(几乎不用了)

​		gteway(重要)

​	服务配置

​		config

​		nacos

​	服务组件

​		Bus

​		nacos

# 二,开始搭建

## 1.创建项目

![1653141740401](%E5%9F%BA%E7%A1%80.assets/1653141740401.png)

## 2.修改pom

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.xzw</groupId>
  <artifactId>springcloud</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <!--统一管理jar包版本-->
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>12</maven.compiler.source>
    <maven.compiler.target>12</maven.compiler.target>
    <junit.version>4.12</junit.version>
    <lombok.version>1.18.10</lombok.version>
    <log4j.version>1.2.17</log4j.version>
    <mysql.version>8.0.19</mysql.version>
    <druid.version>1.1.16</druid.version>
    <mybatis.spring.boot.version>2.1.1</mybatis.spring.boot.version>
  </properties>
  <!--子模块继承之后，提供作用：锁定版本+子module不用谢groupId和version-->
  <dependencyManagement>
  <dependencies>
  <dependency>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-project-info-reports-plugin</artifactId>
    <version>3.0.0</version>
  </dependency>
  <!--spring boot 2.2.2-->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.2.2.RELEASE</version>
    <type>pom</type>
    <scope>import</scope>
  </dependency>
  <!--spring cloud Hoxton.SR1-->
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-dependencies</artifactId>
    <version>Hoxton.SR1</version>
    <type>pom</type>
    <scope>import</scope>
  </dependency>
  <!--spring cloud 阿里巴巴-->
  <dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
    <version>2.1.0.RELEASE</version>
    <type>pom</type>
    <scope>import</scope>
  </dependency>
  <!--mysql-->
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>${mysql.version}</version>
    <scope>runtime</scope>
  </dependency>
  <!-- druid-->
  <dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>${druid.version}</version>
  </dependency>
    <!--mybatis-->
    <dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>${mybatis.spring.boot.version}</version>
    </dependency>
    <!--junit-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>${junit.version}</version>
    </dependency>
    <!--log4j-->
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>${log4j.version}</version>
    </dependency>
  </dependencies>
  </dependencyManagement>
</project>

```

## 3.写yml

```yml
server:
  port: 8001            #端口号
spring:
  application:
    name: cloud-payment-service       #服务器名称
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource      #当前数据源操作类型
    driver-class-name: com.mysql.jdbc.Driver        #mysql驱动包
    url: jdbc:mysql://localhost:3306/cloud?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC
    username: root
    password: 123456

mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.atguigu.springcloud.entities
 
 
```

## 4.主启动

```java
@SpringBootApplication
public class paymentMain8001 {
    public static void main(String[] args) {
        SpringApplication.run(paymentMain8001.class,args);
    }
}

```

## 5.数据库

DROP TABLE IF EXISTS `payment`;
CREATE TABLE `payment`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `serial` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of payment
-- ----------------------------
INSERT INTO `payment` VALUES (2, '45');
INSERT INTO `payment` VALUES (3, '零七');
INSERT INTO `payment` VALUES (7, '零七');
INSERT INTO `payment` VALUES (31, 'aaa');
INSERT INTO `payment` VALUES (32, '零七');
INSERT INTO `payment` VALUES (33, '789');

SET FOREIGN_KEY_CHECKS = 1;

## 6.三层架构

![1653286327101](%E5%9F%BA%E7%A1%80.assets/1653286327101.png)

## 7.,mapper映射文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xzw.springCloud.Mapper.PaymentMapper">
    <resultMap id="BaseResultMap" type="com.xzw.springCloud.entities.Payment">
        <id column="id" jdbcType="BIGINT" property="id" />
        <result column="serial" jdbcType="VARCHAR" property="serial" />
    </resultMap>
    <insert id="insert" parameterType="payment" useGeneratedKeys="true" keyProperty="id">
        insert into Payment (id, serial)
        values (#{id}, #{serial})
    </insert>
    <select id="getPaymentByID" parameterType="Long" resultMap="BaseResultMap">
        select *
        from Payment
        where id = #{id}
    </select>
    <select id="getPaymentAll" parameterType="Long" resultMap="BaseResultMap">
        select *
        from Payment
    </select>
</mapper>
```

## 8.测试

![1653306025154](%E5%9F%BA%E7%A1%80.assets/1653306025154.png)



![1653306033295](%E5%9F%BA%E7%A1%80.assets/1653306033295.png)

# 三.用户模块访问订单模块

## 1.创建项目

同上

## 2.修改pom

同上

## 3.写yml

同上

## 4.设置启动类

同上

## 5.工具类

添加获取RestTemplate的工具类

RestTemplate提供了多种便捷访问远程Http服务的方法，
是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集

```java
@Configuration
public class ApplicationContextConfig {
    @Bean
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }
}
```

## 6.控制器

```java
@RestController
@Slf4j
public class OrderController {
    public static final String payment_url="http://localhost:8001";
    @Resource
    private RestTemplate restTemplate;
    @GetMapping("/consumer/payment/insert")
    public CommonResult insert(Payment payment){
        log.info("用户添加了:"+payment);
        return restTemplate.postForObject(payment_url+"/payment/insert",payment,CommonResult.class);
    }
    @GetMapping("/consumer/payment/get/{id}")
    public CommonResult getPaymentByID(@PathVariable("id") Long id){
        log.info("用户根据id查询:id="+id);
        return restTemplate.getForObject(payment_url+"/payment/get/"+id,CommonResult.class);
    }
    @GetMapping("/consumer/payment/getAll")
    public CommonResult getPaymentAll(Payment payment){
        log.info("用户查询所有");
        return restTemplate.getForObject(payment_url+"/payment/getAll",CommonResult.class);
    }
}
```

## 7.测试

![1653306371688](%E5%9F%BA%E7%A1%80.assets/1653306371688.png)

![1653306383865](%E5%9F%BA%E7%A1%80.assets/1653306383865.png)

# 四.设置公用类

发现这两个实体类都是一样的.设计一个公用模块

## 1.创建项目

同上

## 2.修改pom

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
        <version>5.1.0</version>
    </dependency>
</dependencies>
```

## 3.创建公用实体类

略

## 4.改造前两个模块

前两个模块删除实体类,pom添加

```xml
<dependency>
    <groupId>com.atguigu.springcloud</groupId>
    <artifactId>cloud-api-common</artifactId>
    <version>${project.version}</version>
</dependency>
```

## 5.测试

ok,略

# 五,Eureka

## 1.建立服务的注册中心

### a.创建项目

略

### b.修改pom

```xml
<dependencies>
    <!--eureka-server表示是注册中心-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
    <dependency>
        <groupId>com.atguigu.springcloud</groupId>
        <artifactId>cloud-api-common</artifactId>
        <version>${project.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <!--一般为通用配置-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
 
 

```

### c.写yml

```yml
server:
  port: 7001            #端口号

eureka:
  instance:
    hostname: localhost #eureka服务费的实例名称
  client:
    register-with-eureka: false #表示不会向注册中心注册自己
    fetch-registry: false       #表示自己端就是注册中心,用处就是维护服务实例,并不需要去检索服务
    service-url:
      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

### d.启动类

```java
@SpringBootApplication
@EnableEurekaServer//server是服务端
public class EurekaMain7001 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaMain7001.class,args);
    }
}
```

## 2.客户端注册

### a.pom添加

```xml

        <!--eureka-client客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
```

### b.客户端yml添加

```yml
eureka:
  client:
    register-with-eureka: true  #表示会向注册中心注册自己
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:7001/eureka
```

### c,启动类

```java
@SpringBootApplication
@EnableEurekaClient//客户端
public class paymentMain8001 {
    public static void main(String[] args) {
        SpringApplication.run(paymentMain8001.class,args);
    }
}

```

### d.测试

![1653309513998](%E5%9F%BA%E7%A1%80.assets/1653309513998.png)



## 3.设置集群服务注册中心

### a.修改hosts文件

找到C:\Windows\System32\driversletc路径下的hosts文件,添加

![1653319610842](%E5%9F%BA%E7%A1%80.assets/1653319610842.png)

### b,设置eureka互相依赖

例如a依赖b,b依赖c,c依赖a

![1653319669626](%E5%9F%BA%E7%A1%80.assets/1653319669626.png)

![1653319676832](%E5%9F%BA%E7%A1%80.assets/1653319676832.png)

c,修改客户端yml

![1653319723763](%E5%9F%BA%E7%A1%80.assets/1653319723763.png)

d.测试

7001:

![1653373451935](%E5%9F%BA%E7%A1%80.assets/1653373451935.png)

7002:

![1653373466565](%E5%9F%BA%E7%A1%80.assets/1653373466565.png)

4.设置用户端

订单服务访问地址不能写死,要不然只能一直访问8001.设置成订单模块的服务器名称,并且开启负载均衡

a.修改用户端的controller

```java
//单机版服务注册执行可以固定ip,但是集群版就要写服务名称了,让服务注册中心去负载均衡
//    public static final String payment_url="http://localhost:8001";
    public static final String payment_url="http://cloud-payment-service";
```

b.工具类开启负载均衡

```java
@Configuration
public class ApplicationContextConfig {
    @Bean
    @LoadBalanced       //开启负载均衡
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }
}
```

c.订单模块的yml

设置成一样的

```yml
spring:
  application:
    name: cloud-payment-service       #服务器名称
```

d.测试

发现Eureka上有两个 **CLOUD-PAYMENT-SERVICE** 了,并且用户端访问时是8001和8002来回切换

![1653402043428](%E5%9F%BA%E7%A1%80.assets/1653402043428.png)

![1653402055107](%E5%9F%BA%E7%A1%80.assets/1653402055107.png)

![1653402065961](%E5%9F%BA%E7%A1%80.assets/1653402065961.png)

## 改进

### 1.主机名称

发现服务注册中心含有主机名称要修改,修改主机yml

![1653373552842](%E5%9F%BA%E7%A1%80.assets/1653373552842.png)

![1653373584706](%E5%9F%BA%E7%A1%80.assets/1653373584706.png)

### 2.ip提示

服务注册中心没有ip提示

![1653373624444](%E5%9F%BA%E7%A1%80.assets/1653373624444.png)

![1653373640058](%E5%9F%BA%E7%A1%80.assets/1653373640058.png)

![1653373663501](%E5%9F%BA%E7%A1%80.assets/1653373663501.png)

### 3.服务信息

对于注册eureka里面的微服务,可以通过服务发现来获得该服务的信息,怎么获取?

修改客户端的controller

```java
import org.springframework.cloud.client.discovery.DiscoveryClient; 
//服务发现  获取服务信息
    @Resource
    private DiscoveryClient discoveryClient;
    //服务发现
    @GetMapping("/payment/dis")
    public Object discovery(){
        List<String> service = discoveryClient.getServices();
        for (String element :service){
            log.info("---getServices---:"+element);
        }
        //一个微服务下的全部实例   指是该服务器的名称
        List<ServiceInstance> instances = discoveryClient.getInstances("cloud-payment-service");
        for (ServiceInstance ser : instances){
            log.info("---getInstances---"+ser.getServiceId()+"\t"+ser.getHost()+"\t"+ser.getPort()+"\t"+ser.getUri());
        }
        return discoveryClient;
    }
```

修改启动类的EnableEurekaClient,改为EnableDiscoveryClient

测试成功

![1653374073801](%E5%9F%BA%E7%A1%80.assets/1653374073801.png)

## 关闭自动保护机制

#### 为什么会产生Eureka自我保护机制?

为了防止EurekaClient可以正常运行，但是与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除

#### 什么是自我保护模式?

默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。

自我保护机制:默认情况下Eurekaclient定时向EurekaServer端发送心跳包

如果Eureka在server端在一定时间内(默认90秒)没有收到EurekaClient发送心跳包，便会直接从服务注册列表中剔除该服务，但是在短时间(90秒中)内丢失了大量的服务实例心跳，这时候EurekaServer会开启自我保护机制，不会剔除该服务（该现象可能出现在如果网络不通但是EurekaClient为出现宕机，此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的)

**在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。**

它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解:**好死不如赖活着**
综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微L务都会保留)也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。

一句话:某时刻一个微服务不可用了,Eureka不会立刻清理,依旧会对该服务的信息进行保存,属于CAP里面的AP分支

服务端:

```yml
eureka:
  instance:
    # eureka服务端的实例名称
    hostname: eureka7001.com
  client:
    # false表示不向注册中心注册自己
    register-with-eureka: false
    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务
    fetch-registry: false
    service-url:
       defaultZone: http://eureka7001.com:7001/eureka/
  server:
    #关闭自我保护机制,保证不可用的服务及时清除
    enable-self-preservation: false
    #超过多少时间没有心跳就清除服务,单位毫秒
    eviction-interval-timer-in-ms: 2000


```

客户端

```yml
eureka:
  client:
    register-with-eureka: true  #表示会向注册中心注册自己
    fetch-registry: true
    service-url:
      # 集群版
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
  instance:
    instance-id: payment8001  #在服务注册中心显示的名称
    prefer-ip-address: true  #访问路径可以显示ip地址
    lease-renewal-interval-in-seconds: 1      #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)
    lease-expiration-duration-in-seconds: 2   #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务

```

# 六,使用OpenFeign服务接口调用

## 是什么?

Feign是一个声明式的Web服务客户端,让编写Web服务客户端变得非常容易,只需  创建一个接口并在接口上添加注解即可

https://github.com/spring-cloud/spring-cloud-openfeign

## 1.pom

```xml
    <dependencies>
        <!--openfeign-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!--eureka client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        <dependency>
            <groupId>com.xzw</groupId>
            <artifactId>cloud-api-commons</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--监控-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--热部署-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>

```

## 2.yml

```yml
server:
  port: 80
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka


```

## 3.启动类

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class OrderFeignMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderFeignMain80.class,args);
    }
}

```



## 4.service

```java
import com.xzw.springCloud.entities.CommonResult;
import com.xzw.springCloud.entities.Payment;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Component
//要调用服务器的名称
@FeignClient(value = "CLOUD-PAYMENT-SERVICE")
public interface PaymentFeignService {
    //要调用的方法
    @GetMapping("/payment/get/{id}")
    CommonResult<Payment> getPaymentByID(@PathVariable("id") Long id);
}

```

## 5.controller

```java
package com.xzw.springCloud.controller;

import com.xzw.springCloud.entities.CommonResult;
import com.xzw.springCloud.service.PaymentFeignService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderFeignController {
    @Resource
    private PaymentFeignService paymentFeignService;
    @GetMapping("/consumer/payment/get/{id}")
    public CommonResult getPaymentByID(@PathVariable("id") Long id){
        log.info("用户根据id查询:id="+id);
        return paymentFeignService.getPaymentByID(id);
    }
}

```

## 6.测试

![1653895091471](%E5%9F%BA%E7%A1%80.assets/1653895091471.png)

![1653895099358](%E5%9F%BA%E7%A1%80.assets/1653895099358.png)

8001和800交替出现

## 7.总结

![1653895278503](%E5%9F%BA%E7%A1%80.assets/1653895278503.png)

## OpenFeign超时控制

OpenFeign默认等待1秒钟,超过后报错,但是服务器处理数据时间可能会超过1秒,需要设置等待超时时间

超时测试:

![1653896053911](%E5%9F%BA%E7%A1%80.assets/1653896053911.png)

可以在yml里面设置

```yml
# 设置feign客户端超时时间(OpenFeign默认支持ribbon)
ribbon:
  # 指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间
  ReadTimeout: 5000
  # 指的是建立连接后从服务器读取到可用资源所用的时间
  ConnectTimeout: 5000
```

## 日志

Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http 请求的细节。说白了就是对Feign接口的调用情况进行监控和输出

NONE:默认的，不显示任何日志;
BASIC:仅记录请求方法、URL、响应状态码及执行时间;
HEADERS:除了BASIC中定义的信息之外，还有请求和响应的头信息;
FULL:除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。

### 配置日志:

```java
import feign.Logger;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * OpenFeignClient配置
 **/
@Configuration
public class FeignConfig {

    /**
     * feignClient配置日志级别
     */
    @Bean
    public Logger.Level feignLoggerLevel() {
        // 请求和响应的头信息,请求和响应的正文及元数据
        return Logger.Level.FULL;
    }
}
```

### yml

```yml
logging:
  level:
    # feign日志以什么级别监控哪个接口
    com.xzw.springCloud.service.PaymentFeignService: debug
```



### 结果

![1653896438819](%E5%9F%BA%E7%A1%80.assets/1653896438819.png)

# 七,Hystrix熔断器

## 服务雪崩

​	多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.

​	对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。
​	所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。

## 服务降级

1.如果服务器繁忙,就是有多个用户同时链接服务器,就会卡。这时候就返回 " 请稍后再试 " ,不让客户端等待并立刻返回一个友好提示

2.如果服务器出现问题,比如异常,发生熔断,这时候也不会继续调用服务器接口,而是返回一个信息,不再继续调用服务器接口

### 	a,pom

```xml
        <!--hystrix-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
```

### b.yml

```yml
server:
  port: 8001
spring:
  application:
    name: cloud-provider-hystrix-payment
eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
```

### c.主启动

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

/**
 * @author zzyy
 * @create 2020/3/6 22:21
 **/
@SpringBootApplication
@EnableEurekaClient
public class PaymentHystrixMain8001 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentHystrixMain8001.class, args);
    }
}
```

### d.service

```java
    }
    //模拟程序超时
    /*
    *@HystrixCommand 服务熔断
    * fallbackMethod服务出问题执行的方法,参数是方法名
    *   @HystrixProperty
    *       name什么问题
    *       value,值
    * 1.name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000"
    * 设置了最大链接时间是3秒,但是我设置了睡眠5秒这时候就会发生服务降级,直接调用paymentInfo_TimeOutHandler方法返回结果
    *
    */
    @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")
    })
    public String paymentInfo_TimeOut(Integer id){
//        int a = 10/0;
        int time = 5;
        try {
            TimeUnit.SECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "线程池"+Thread.currentThread().getName()+"\tpaymentInfo_TimeOut,id:"+id+"超时"+time+"秒!!!";
    }
    public String paymentInfo_TimeOutHandler(Integer id){
        return "线程池"+Thread.currentThread().getName()+"\tpaymentInfo_TimeOutHandler,id:"+id+",抱歉,连接超时或者程序运行错误";
    }
```

### e.测试

测试成功,忘记截图了

### f.改进

#### 1.每个方法配置一个吗

每个方法配置一个的话代码量太大了

可以在类上面添加@DefaultProperties(defaultFallback = "方法名")

要实现服务降级的方法上面就添加@HystrixCommand就可以了,如果发生了服务降级就会调用类上面的方法名的方法

如果自己要单独设置一个发生降级后调用的方法,也可以单独设置一个

![1654225423396](%E5%9F%BA%E7%A1%80.assets/1654225423396.png)

#### 2.和业务逻辑混在一起了

降级方法和业务逻辑层混在一起看起来也很混乱,把降级方法单独设置成一个类

##### 1.yml

```yml
feign:
  hystrix:
    enabled: true   #在feign中开启hystrix

```

##### 2.service

在service成创建一个类,实现要方法降级的接口

接口:

```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
@Component
//要调用服务器的名称,fallback服务降级类
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT8001",fallback = PaymentHystrixServiceImpl.class)
public interface PaymentHystrixService {
    @GetMapping("/payment/hystrix/ok/{id}")
    String paymentInfo_OK(@PathVariable("id") Integer id);
    @GetMapping("/payment/hystrix/timeout/{id}")
    String paymentInfo_TimeOut(@PathVariable("id") Integer id);

}
```

服务降级类:

```java
@Component
//兜底类,如果PaymentHystrixService接口没有问题就正常使用,如果出现问题就用这个类兜底
public class PaymentHystrixServiceImpl implements PaymentHystrixService {
    @Override
    public String paymentInfo_OK(Integer id) {
        return "PaymentHystrixServiceImpl----paymentInfo_OK";
    }
    @Override
    public String paymentInfo_TimeOut(Integer id) {
        return "PaymentHystrixServiceImpl----paymentInfo_TimeOut";
    }
}
```



## 服务熔断

### 熔断机制概述

熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。
**当检测到该节点微服务调用响应正常后，恢复调用链路。**
在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，
当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand.。

### service:

```java
    //服务熔断
    //如果拍写错了可以打开 HystrixPropertiesManager 类,里面有常量
    @HystrixCommand(fallbackMethod = "PaymentCircuitBreaker_fallback",commandProperties = {
            @HystrixProperty(name = "circuitBreaker.enabled",value = "true"),//是否开启熔断器
            @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),//请求次数
            @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),//时间窗口期
            @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60")//失败率达到多少跳闸
    })
    public String PaymentCircuitBreaker(Integer id){

        if (id < 0) {
            throw new RuntimeException("id不能是负数");
        }
        String serialNumber = IdUtil.simpleUUID();
        return Thread.currentThread().getName()+"调用成功,流水号:"+serialNumber;
    }

    private String  PaymentCircuitBreaker_fallback(Integer id){
        return "id不能是负数,id="+id;
    }
```

正确

![1654225837017](%E5%9F%BA%E7%A1%80.assets/1654225837017.png)

错误

![1654225841751](%E5%9F%BA%E7%A1%80.assets/1654225841751.png)

多次错误一次正确

![1654225848162](%E5%9F%BA%E7%A1%80.assets/1654225848162.png)

发生就算我们输入正确的还是会发生服务熔断,要多次输入正确或者等一下才会正确显示结果

### 断路器开启或者关闭的条件

1. 当满足一定的闽值的时候(默认10秒钟超过20个请求次数)
2. 当失败率达到一定的时候(默认10秒内超过50%的请求次数)
3. 到达以上阙值,断路器将会开启
4. 当开启的时候,所有请求都不会进行转发
5. 一段时间之后(默认5秒),这个时候断路器是半开状态,会让其他一个请求进行转发.如果成功,断路器会关闭,若失败,继续开启.重复4和5

### 总结

涉及到断路器的三个重要参数:**快照时间窗、请求总数阀值、错误百分比阀值**。
1∶快照时间窗:断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
2:请求总数阀值:在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。
3:错误百分比阀值:当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。

## 服务监控hystrixDashboard

除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。

### 新建模块

#### 1.pom

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>springcloud</artifactId>
        <groupId>com.xzw</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>cloud-consumer-hystrix-dashboard9001</artifactId>
    <dependencies>
        <!--hystrix dashboard图形化界面-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
        </dependency>
        <!--监控-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--热部署-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

#### 2.yml

```yml
server:
  port: 9001
```

#### 3.main

```java
package com.xzw.springCloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;

@SpringBootApplication
@EnableHystrixDashboard//新注解
public class HystrixDashboardMain9001 {
    public static void main(String[] args) {
       SpringApplication.run(HystrixDashboardMain9001.class,args);
    }

}
```

#### 4.pom

在需要开启服务监控的模块pom添加

```xml
<!--监控-->
<dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-actuator</artifactId></dependency>
```

#### 5.启动

先开启服务监控,再开启服务注册,最后开启要监控的服务

http://localhost:9001/hystrix

![1654227978512](%E5%9F%BA%E7%A1%80.assets/1654227978512.png)

9001监控8001,填写监控地址

http://localhost:8001/hystrix.stream

![1654228056155](%E5%9F%BA%E7%A1%80.assets/1654228056155.png)

多次输入错误后

![1654228085552](%E5%9F%BA%E7%A1%80.assets/1654228085552.png)

怎么看:

![1654228135367](%E5%9F%BA%E7%A1%80.assets/1654228135367.png)

![1654228144539](%E5%9F%BA%E7%A1%80.assets/1654228144539.png)

![1654228149645](%E5%9F%BA%E7%A1%80.assets/1654228149645.png)

# 八,Gateway新一代网关

## Gateway是什么

Gateway是在Spring生态系统上构建的API网关服务，基于Spring5,Spring Boot2和Project Reactor等技术开发的网关

Gateway指在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如：熔断、限流、重试等

SpringCloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Zuul,在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，Spring Cloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通过框架Netty

## 网关是什么

 ![img](%E5%9F%BA%E7%A1%80.assets/442c7ba262834c8b8b94a12d0e0cc9f7.png) 

## Gateway与Zuul的区别

在Spring Cloud Finchley正式版之前 ，Spring Cloud推荐的网关是Netflix提供的Zuul：

1）Zuul 1.x是一个基于阻塞I/O的API Gateway

2）Zuul 1.x是基于Servlet 2.5使用阻塞架构它不支持任何长连接（如WebSocket)Zull的设计模式和Nginx较像，每次I/O操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别Nginx用C++实现，Zuul用Java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul性能相对较差

3）Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul 2.x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS（每秒请求数）是Zuul的1.6倍

4）Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot 2之上，使用非阻塞API

5）Spring Cloud Gateway还支持WebSocket,并且与Spring紧密集成拥有更好的开发体验

### Zuul的缺点

 Springcloud中集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Servlet **IO处理模型。** 

当请求进入servelt container时，servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。但是一旦高并发（比如抽风用jemeter压），线程数量就会上涨 ，崦线程资源代价是昂贵的（上下文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servelt模型没有优势

所以Zuul 1.x是基于servelt之上的一个阻塞式处理模型，即spring实现了处理所有的request请求的一个servelt(DispatcherServelt)并由该servelt阻塞式处理。所以Sprinng cloud Zull无法摆脱servlet模型的弊端

### Gateway模型

#### WebFlux是什么

传统的Web框架，比如说：struts2,springmvc等都是基于Servlet API 与Servlet 容器基础之上运行的。

但是Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reacor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty,Undertow及支持Servlet 3.1的容器上。非阻塞式+函数式编程（Spring5必须让你使用Java8）

Spring WebFlux是Spring 5.0引入的新的响应式框架，区别于Spring MVC,它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范

## 三大核心概念

### Route(路由)

路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由

### Predicate(断言)

参考的是Java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由

### Filter(过滤)

指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改.

### 总结

web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。
predicate就是我们的匹配条件:而fiter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了

### Gateway工作流程

客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。
Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。
过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post”)执行业务逻辑.
Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，
在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。

## 怎么使用

### 1.pom

```xml
    <dependencies>
        <!--gateway-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--eureka-client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--引入自己定义的工具类-->
        <dependency>
            <groupId>com.xzw</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <!--web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>
<!--        热部署-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
 

```

### 2.yml

```yml
server:
  port: 9527            #端口号
spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称进行路由
      routes:
        - id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名
          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service
#          uri: http://localhost:8001
          predicates:
            - Path=/payment/get/** # 断言，路径相匹配的进行路由
#            - After=2022-06-04T21:00:00.000+08:00[Asia/Shanghai]  #时间,必须要这个时间之后才能调用
#            - Cookie=username,xzw                                 #cookies,前面是名称,后面是正则表达式,必须匹配上才可以访问
#            - Header=xzw,\d+                                      #请求头要有xzw,并且值必须是整数
        - id: payment_route2
          uri: lb://cloud-payment-service
          predicates:
            - Path=/payment/lb/**
            - Cookie=username,xzw
            - After=2022-06-04T20:50:27.274+08:00[Asia/Shanghai]
            - Header=xzw,\d+
eureka:
  instance:
    instance-id: gateway  #在服务注册中心显示的名称
    prefer-ip-address: true  #访问路径可以显示ip地址
    hostname: cloud-gateway-service
  client:
    register-with-eureka: true  #表示会向注册中心注册自己
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka
```

### 3.启动类

```java
@SpringBootApplication
@EnableEurekaClient
public class GatWayMain9527 {
    public static void main(String[] args) {
        SpringApplication.run(GatWayMain9527.class, args);
    }

}
```



### 4.自定义路由

访问:http://localhost:9527/index.html时,会自动跳转到https://tieba.baidu.com/index.html里

```java
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GateWayConfig {
    /*
    * 配置了一个id为customRouteLocator_baidu的路由规则:
    *   当访问是http://localhost:9527/index.html时,会自动跳转到https://tieba.baidu.com/index.html里,
    * 注意两个路径的后面(index.html)要是一样的,不一样会报404错误
    * */
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder  routeLocatorBuilder){
        RouteLocatorBuilder.Builder routes=routeLocatorBuilder.routes();
        routes.route("customRouteLocator_baidu", //id,必须唯一
                r ->r.path("/index.html")   //输入的url
                        .uri("https://tieba.baidu.com/index.html"))   //映射的url,意思就是你输入guonei,会访问到https://www.baidu.com/里
                            .build();
        return routes.build();
    }
}
```

### 5.Predicate

Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以进行组合

例子:

```yml
spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称进行路由
      routes:
        - id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名
          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service
#          uri: http://localhost:8001
          predicates:
            - Path=/payment/get/** # 断言，路径相匹配的进行路由
#            - After=2022-06-04T21:00:00.000+08:00[Asia/Shanghai]  #时间,必须要这个时间之后才能调用
#            - Cookie=username,xzw                                 #cookies,前面是名称,后面是正则表达式,必须匹配上才可以访问
#            - Header=xzw,\d+                                      #请求头要有xzw,并且值必须是整数
        - id: payment_route2
          uri: lb://cloud-payment-service
          predicates:
            - Path=/payment/lb/**
            - Cookie=username,xzw
            - After=2022-06-04T20:50:27.274+08:00[Asia/Shanghai]
            - Header=xzw,\d+
```

### 6.自定义过滤器

添加了一个自定义过滤器,要求是url传过来时必须要带一个uname,不能为null,如果没有就会访问不了

```java
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Date;

@Configuration
public class MuLogGateWayFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println("*******过滤器*********"+new Date());
        //获取uname的参数
        String uname = exchange.getRequest().getQueryParams().getFirst("uname");
        //如果是null
        if (uname == null) {
            System.out.println("非法用户");
            //返回状态码406
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            //返回信息
            return exchange.getResponse().setComplete();
        }
        //放行
        return chain.filter(exchange);
    }
    //顺序
    @Override
    public int getOrder() {
        return 0;
    }
}
```

### 7.测试

#### 网关

1.没有网关前

![1654409696491](%E5%9F%BA%E7%A1%80.assets/1654409696491.png)

2.添加网关后,8001和8002是交替的

![1654409709296](%E5%9F%BA%E7%A1%80.assets/1654409709296.png)

过滤器

设置了uname

![1654410085641](%E5%9F%BA%E7%A1%80.assets/1654410085641.png)

没有设置

![1654410102364](%E5%9F%BA%E7%A1%80.assets/1654410102364.png)



# 九,Config分布式配置中心

## 微服务配置问题?

微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。
SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理..….比如要修改数据库密码,要一个一个修改,太麻烦了

## SpringCloud Config是什么

SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。

## 怎么玩

### 服务端

服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口

### 客户端

客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容

## 有什么用

1. 集中管理配置文件
2. 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release
3. 运行期间动态调整配置，不再需要字啊每个服务器的机器上编写配置文件，服务会向配置中心同意拉去配置自己的信息
4. 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置
5. 将配置信息以REST接口的形式暴露,post,curl访问刷新均可

可以与githup/gitee整合

但是githup连外网太耗流量了,还是用gitee

https://gitee.com/xzwgii/springcloud-config

## 怎么使用

### 1.gitee新建仓库springcloud-config

再上传一个config-dev.yml文件

```yml
config:
 info: "master branch, springcloud-config/confg-dev.yml version=2"
 con: "master branch, springcloud-config/confg-dev.yml version=3"
 name: xzw
```

//要提交的代码
git add application-dev.yml
//注释
git commit -m "application-dev.yml"
//推送到主分支
git push -u origin "master"
//推送到主分支的dev分支
git push -u origin "master:dev"



![1654506302342](%E5%9F%BA%E7%A1%80.assets/1654506302342.png)



### 2.服务端,新建模块

cloud-config-center-3344,即为Cloud的配置中心模块cloudCofing Center

### 3.pom

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-config-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.xzw</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
```

### 4.yml

```yml
server:
  port: 3344
eureka:
  client:
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/
spring:
  application:
    name: cloud-config-center
  cloud:
    config:
      server:
        git:
          #gitee上面的仓库地址
          uri:  https://gitee.com/xzwgii/springcloud-config.git
          #账号密码,gitee上不允许公开仓库了??
          username: *********
          password: *********
          #搜索目录
          search-paths:
            - springcloud-config
      #读取分支
      label: master


```

记得添加映射:

127.0.0.1 config-3344.com

### 5.启动类

```java
@SpringBootApplication
@EnableConfigServer
public class AppConfigCenterMain3344 {
    public static void main(String[] args) {
        SpringApplication.run(AppConfigCenterMain3344.class,args);
    }
}

```

### 6.测试

成功

![1654506503833](%E5%9F%BA%E7%A1%80.assets/1654506503833.png)

### 7.客户端,新建模块

cloud-config-center-3355

### 8.pom

```xml
    <artifactId>cloud-config-center-3355</artifactId>
    <dependencies>
<!--        config客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-bus-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.xzw</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
<!--        没加这个会报错-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
```

### 9.bootstrap.yml

#### 是什么?

**applicaiton.ym1是用户级的资源配置项**
**bootstrap.yml是系统级的，优先级更加高**
Spring Cloud会创建一个“BootstrapContext”，作为Spring应用的'Application Context的父上下文。初始化的时候，'BootstrapContext'负责从外部源加载配置属性并解析配置。这两个t下文共享一个从外部获取的'Environment'。

'Bootstrap'属性有高优先级，默认情况下，它们不会被本地配置覆盖。"Bootstrap context和Application Context'有着不同的约定，所以新增了一个'bootstrap.yml文件，保证'Bootstrap Context和T'Application Context'配置的分离。

要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的.
因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml

````YML
server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    config:
      label: master  #分支名称
      name: config  #配置文件名称
      profile: dev  #读取后缀名称   上述三个综合http://localhost:3344/master/config-dev.yml
      uri: http://localhost:3344  #配置中心的地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
````

### 10.启动类

```java
package com.xzw.springCloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@EnableEurekaClient
@SpringBootApplication
public class ConfigClientMain3355 {
    public static void main(String[] args) {
        SpringApplication.run(ConfigClientMain3355.class,args);
    }
}
```

11.controller

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
//前两个我也不知道什么用的,但是官网加了,老师是只要后两个就行
@Configuration
@EnableAutoConfiguration
@RestController
@RefreshScope
public class ConfigClientController {
    @Value("${config.name}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String getConfigInfo(){
        return configInfo;
    }
}

```

### 11.测试

成功

![1654506794423](%E5%9F%BA%E7%A1%80.assets/1654506794423.png)

### 12.动态刷新

避免每次更新配置都要重启客户端微服务3355

pom添加监控模块

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

修改YML,暴露监控接口

```yml
#暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"

```

controller添加@RefreshScope注解

测试还是不成功,为什么?

需要发送Post请求刷新3355

注意,必须是post请求

http://localhost:3355/actuator/refresh

![1654506941297](%E5%9F%BA%E7%A1%80.assets/1654506941297.png)

测试成功!



# 十,Bus消息总线

上一章实现了config可以从gitee上获取,但是有一个问题,如果微服务太多了怎么办?难道要一个一个的刷新吗?

这个时候就可以使用SpringCloud Bus配合Springcloud Config使用可以实现配置的动态刷新

## 是什么

Bus支持两种消息代理：RabbitMQ和kafka

![1654524919593](%E5%9F%BA%E7%A1%80.assets/1654524919593.png)

Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，
**它整合了Java的事件处理机制和消息中间件的功能。**
Spring Clud Bus目前支持**RabbitMQ**和Kafka。

## 能干嘛

Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务中的通信通道

## 什么是总线

在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个公用的消息主题，并让系统中的所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他链接在该主题行的实例都知道的消息。

基本原来理：
ConfigClient实例都监听MQ中的同一个topic（默认是SpringcloudBus）。当一个服务刷新数据的时候，它会把这个信息放入到topic中，这样其它监听同一个topic的服务就能得到通知，然后去更新自身的配置。

教程:


http://www.bilibili.com/video/av55976700?from=searche&seid=15010075915728605208

## RabbitMQ环境配置

### 1.Erlang

首先要安装Erlang,githup要连外网,我就直接从好心人那里拷了一份

https://github.com/erlang/otp/releases/download/OTP-25.0/otp_win64_25.0.exe

### 2.下载安装RabbitMQ

### 3.sbin目录

进入RabbitMq的sbin目录,输入命令开启安装功能,安装可视化插件

rabbitmq-plugins enable rabbitmq_management

![1654525169572](%E5%9F%BA%E7%A1%80.assets/1654525169572.png)![1654525172670](%E5%9F%BA%E7%A1%80.assets/1654525172670.png)

点击start启动服务,stop关闭服务

浏览器输入http://localHost:15672/  查看是否启动成功
账号密码默认都是guest

## 怎么使用

演示广播效果增加复杂度，再以3355为模板制作一个3366,直接复制3355改个端口就可以,就不写了

### 1.给3344配置中心服务端添加消息总线支持

```xml
<!--        添加消息总线rabbitmq支持-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
```

### 2.yml

```yml
server:
  port: 3344

eureka:
  client:
    service-url:
      defaultZone: http://www.eureka7001.com:7001/eureka/
  instance:
    ip-address: 127.0.0.1
    prefer-ip-address: true
    lease-renewal-interval-in-seconds: 1
    lease-expiration-duration-in-seconds: 2
spring:
  application:
    name: cloud-config-center
  cloud:
    config:
      server:
        git:
          uri:  https://gitee.com/xzwgii/springcloud-config.git
          username: **
          password: **
          search-paths:
            - springcloud-config
      label: master
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
#rabbitmq相关配置,暴露bus的刷新配置端点
management:
  endpoints:
    web:
      exposure:
        include: 'bus-refresh'
```

### 3.3355pom

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
```

### 4.3355yml

3366一样的

```yml
server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    config:
      label: master  #分支名称
      name: config  #配置文件名称
      profile: dev  #读取后缀名称   上述三个综合http://localhost:3344/master/config-dev.yml
      uri: http://localhost:3344  #配置中心的地址
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest 
eureka:
  client:
    service-url:
      defaultZone: http://www.eureka7001.com:7001/eureka/
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

### 5.测试

1.全局刷新

http://localhost:3344/actuator/bus-refresh

测试成功,3355和3366都刷新了

![1654525441594](%E5%9F%BA%E7%A1%80.assets/1654525441594.png)

2.单个刷新

http://localhost:3344/actuator/bus-refresh/config-client:3355

测试成功,只要33355刷新成功了

# 十一,Stream消息驱动

## 什么是SpringCloudStream

官方定义 Spring Cloud Stream是一个构建消息驱动微服务的框架。

应用程序通过inputs 或者outputs来与Spring Cloud Stream中binder对象交互。通过我们配置来binding(绑定)，而Spring Cloud Stream的 binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。

通过使用Spring lIntegration来连接消息代理中间件以实现消息事件驱动。
Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。
目前仅支持RabbitMQ、Kafka.

简单的来说就是**屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型**

## 设计思想

### 标准MQ

1. 生产者/消费者之间靠消息媒介传递信息内容：Message
2. 消息必须走特定的通道：MessageChannel
3. 消息通道MessageChannel的子接口SubscribeChannel，由MessageHandler消息处理器所订阅

![1654659918745](%E5%9F%BA%E7%A1%80.assets/1654659918745.png)

## Stream凭什么可以统一底层差异

在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性
通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。
通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。
**通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。**

![1654659974926](%E5%9F%BA%E7%A1%80.assets/1654659974926.png)

Stream中的消息通讯方式遵循了发布-订阅模式

使用Topic主题进行广播,在RabbitMQ就是Exchange,在Kafka中就是Topic

**Springcloud Stream标准流程套路**:

![1654660022342](%E5%9F%BA%E7%A1%80.assets/1654660022342.png)

## 案例

首先确认RabbitMQ环境已经OK

### 1.建造消息生产者模块

cloud-stream-rabbitmq-provider8801

### 2.POM

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.xzw</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>
```



### 3.YML

```yml
server:
  port: 8801
spring:
  application:
    name: cloud-stream-privider
  cloud:
    stream:
      binders:   #自此处配置要绑定的rabbitmq的服务信息
        defaultRabbit: #表示定义的名称，用于binding整合
          type: rabbit #消息组件类型
          environment:  # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      bindings:   #服务的整合处理
        output: #这个名字是一个通道的名称,消息生产者
          destination: studyExchange #表示要使用的exchange名称定义
          content-type: application/json #设置消息类型，本次为json
          binder: defaultRabbit  #设置要绑定的消息服务的具体设置
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka/
  instance:
    lease-expiration-duration-in-seconds: 5 #如果现在超过了5秒的间隔
    lease-renewal-interval-in-seconds: 2 #设置心跳的时间间隔
    instance-id: send-8801.com
    prefer-ip-address: true #访问的路径变为IP地址
```

### 4.main

```java
@SpringBootApplication
public class StreamMQMain8801 {
    public static void main(String[] args) {
        SpringApplication.run(StreamMQMain8801.class,args);
    }
}
```



### 5.service

```java
//接口
public interface IMessageProvider {
    String send();
}
//实现类
import com.xzw.springCloud.Service.IMessageProvider;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.support.MessageBuilder;

import javax.annotation.Resource;
import java.util.UUID;

@EnableBinding(Source.class)    //消息推送管道
public class IMessageProviderImpl implements IMessageProvider {
    @Resource
    private MessageChannel output;

    @Override
    public String send() {
        String serial = UUID.randomUUID().toString();
        output.send(MessageBuilder.withPayload(serial).build());
        return serial;
    }
}
```



### 6.controller

```java
import com.xzw.springCloud.Service.IMessageProvider;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
@RestController
public class SendMessageController {
    @Resource
    private IMessageProvider messageProvider;
    @GetMapping("/sendMessage")
    public String sendMessage(){
        return messageProvider.send();
    }
}

```

### 7.测试:



浏览器一直访问http://localhost:8801/sendMessage网站,http://localhost:15672/显示有波动

![1654660306720](%E5%9F%BA%E7%A1%80.assets/1654660306720.png)

### 8.建造消息消费者模块

### 9.pom

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.xzw</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>

```



### 10.yml

```yml
server:
  port: 8805
spring:
  application:
    name: cloud-stream-consumer
  cloud:
    stream:
      binders:   #自此处配置要绑定的rabbitmq的服务信息
        defaultRabbit: #表示定义的名称，用于binding整合
          type: rabbit #消息组件类型
          environment:  # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      bindings:   #服务的整合处理
        input: #这个名字是一个通道的名称,消息消费者
          destination: studyExchange #表示要使用的exchange名称定义
          content-type: application/json #设置消息类型，本次为json
          binder: defaultRabbit  #设置要绑定的消息服务的具体设置
#          group: ConsumerA #分组
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka/
  instance:
    lease-expiration-duration-in-seconds: 5 #如果现在超过了5秒的间隔
    lease-renewal-interval-in-seconds: 2 #设置心跳的时间间隔
    instance-id: send-8805.com
    prefer-ip-address: true #访问的路径变为IP地址
```



### 11.main

```java
@SpringBootApplication
public class StreamMQMain8805 {
    public static void main(String[] args) {
        SpringApplication.run(StreamMQMain8805.class,args);
    }
}

```



### 12.controler

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.messaging.Message;
import org.springframework.stereotype.Component;

@Component
@EnableBinding(Sink.class)
public class ReceiveMessageListenerController {
    @Value("${server.port}")
    private String serverPort;

    @StreamListener(Sink.INPUT)
    public void input(Message<String> message){
        System.out.println("消费者一号------->接收到的消息"+message.getPayload()+"\t post:"+serverPort);
    }
}
```

### 13.测试

浏览器一直访问http://localhost:8801/sendMessage网站,控制台输出

![1654660433022](%E5%9F%BA%E7%A1%80.assets/1654660433022.png)

## 分组消费与持久化

依照8804，clone出来一份运行8805

两个问题

### 重复消费问题	

8804/8805同时收到了消息，存在重复消费的问题

#### 为什么?

微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。不同的组是可以消费的，同一个组内会发生竞争关系，只有其中一个可以消费。

8802/8803都变成不同组，group两个不同

![1654660624301](%E5%9F%BA%E7%A1%80.assets/1654660624301.png)

#### 怎么修改?

![1654660652046](%E5%9F%BA%E7%A1%80.assets/1654660652046.png)



改为一样的名称,发现是轮询接收消息了,解决重复消费问题

### 消息持久化问题

也是group属性

把8004和8005都关掉,再把8005的group属性去掉,,这个时候连续访问5次页面,把消息发送到Rabbit

再把8004和8005都打开,发现8004后台打出来了MQ上的消息,8005没有

![1654660835533](%E5%9F%BA%E7%A1%80.assets/1654660835533.png)